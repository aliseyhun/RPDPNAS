package nl.uva.creed.repeated.measure.frequencydependent;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

import nl.uva.creed.evolution.Individual;
import nl.uva.creed.evolution.Population;
import nl.uva.creed.evolution.impl.EqualRepeatedGameStrategyPredicate;
import nl.uva.creed.game.Action;
import nl.uva.creed.repeated.History;
import nl.uva.creed.repeated.RepeatedGameStrategy;

import org.apache.commons.collections.CollectionUtils;

public class HistoryMetaSet {

	// keeps frequencies for each present strategy
	protected ArrayList<RepeatedGameStrategy> strategies = new ArrayList<RepeatedGameStrategy>();
	protected ArrayList<Double> frequencies = new ArrayList<Double>();
	// keeps history generated by round-robin all present strategies
	private String[][] longestHistoryString;

	public HistoryMetaSet(Population population, int horizon) {
		// first build the frequency table
		buildFrequenciesTable(population);
		// buildMatrixOfHistories
		buildMatrix(population, horizon);
	}

	private void buildMatrix(Population population, int horizon) {
		longestHistoryString = new String[strategies.size()][strategies.size()];
		for (int i = 0; i < strategies.size(); i++) {
			RepeatedGameStrategy strategyOne = strategies.get(i);
			for (int j = 0; j < strategies.size(); j++) {
				RepeatedGameStrategy strategyTwo = strategies.get(j);
				longestHistoryString[i][j] = playString(strategyOne,
						strategyTwo, 2 * horizon + 1);
			}
		}

	}

	protected String playString(RepeatedGameStrategy strategyOne, RepeatedGameStrategy strategyTwo,
			int rounds) {
		History history1 = new History();
		History history2 = new History();
		for (int j = 0; j < rounds; j++) {
			Action action1 = strategyOne.nextAction(history2);
			Action action2 = strategyTwo.nextAction(history1);
			history1.addMove(action1);
			history2.addMove(action2);
		}
		return history2.toString();
	}

	

	/**
	 * @return the strategies
	 */
	public ArrayList<RepeatedGameStrategy> getStrategies() {
		return strategies;
	}

	/**
	 * @return the frequencies
	 */
	public ArrayList<Double> getFrequencies() {
		return frequencies;
	}

	/**
	 * @return the longestHistoryString
	 */
	public String[][] getLongestHistoryString() {
		return longestHistoryString;
	}

	protected void buildFrequenciesTable(Population population) {
		Set<RepeatedGameStrategy> strategySet = new LinkedHashSet<RepeatedGameStrategy>();
		for (int i = 0; i < population.getSize(); i++) {
			Individual individual = population.getIndividual(i);
			RepeatedGameStrategy strategy = (RepeatedGameStrategy) individual.getStrategy();
			strategySet.add(strategy);
		}
		double popSizeD = new Integer(population.getSize()).doubleValue();
		for (Iterator<RepeatedGameStrategy> iter = strategySet.iterator(); iter.hasNext();) {
			RepeatedGameStrategy element = (RepeatedGameStrategy) iter.next();
			int count = CollectionUtils.countMatches(
					population.getCollection(), new EqualRepeatedGameStrategyPredicate(
							element));
			double countD = new Integer(count).doubleValue();
			strategies.add(element);
			frequencies.add(countD / popSizeD);
		}
	}

	public int numberOfStrategies() {
		return this.strategies.size();
	}

}
