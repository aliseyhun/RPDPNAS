package nl.uva.creed.repeated.measure.frequencydependent;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

import nl.uva.creed.evolution.Individual;
import nl.uva.creed.evolution.Population;
import nl.uva.creed.evolution.impl.EqualRepeatedGameStrategyPredicate;
import nl.uva.creed.game.Action;
import nl.uva.creed.repeated.History;
import nl.uva.creed.repeated.RepeatedGameStrategy;

import org.apache.commons.collections.CollectionUtils;

public class HistoryMetaSet3D {

	private String[][][] cube;
	// keeps frequencies for each present strategy
	protected ArrayList<RepeatedGameStrategy> strategies = new ArrayList<RepeatedGameStrategy>();
	protected ArrayList<Double> frequencies = new ArrayList<Double>();
	// keeps history generated by round-robin all present strategies
	private int horizon;
	
	/**
	 * @return the longestHistoryString
	 */
	public String[][] getLongestHistoryString() {
		return null;
	}

	

	/**
	 * @return the strategies
	 */
	public ArrayList<RepeatedGameStrategy> getStrategies() {
		return strategies;
	}



	/**
	 * @param strategies the strategies to set
	 */
	public void setStrategies(ArrayList<RepeatedGameStrategy> strategies) {
		this.strategies = strategies;
	}



	/**
	 * @return the frequencies
	 */
	public ArrayList<Double> getFrequencies() {
		return frequencies;
	}



	/**
	 * @param frequencies the frequencies to set
	 */
	public void setFrequencies(ArrayList<Double> frequencies) {
		this.frequencies = frequencies;
	}



	/**
	 * @return the cube
	 */
	public String[][][] getCube() {
		return cube;
	}



	/**
	 * @param cube the cube to set
	 */
	public void setCube(String[][][] cube) {
		this.cube = cube;
	}



	public HistoryMetaSet3D(Population population, int horizon) {
		// first build the frequency table
		buildFrequenciesTable(population);
		// buildMatrixOfHistories
		buildMatrix(population, horizon);
	}

	private String playString(RepeatedGameStrategy strategyOne, RepeatedGameStrategy strategyTwo, int rounds, int flippingPoint) {
		History history1 = new History();
		History history2 = new History();
		for (int j = 0; j < rounds; j++) {
			Action action1 = strategyOne.nextAction(history2);
			Action action2 = strategyTwo.nextAction(history1);
			if (j == flippingPoint) {
				if (action2.isCooperate()) {
					action2 = Action.DEFECT;
				} else {
					action2 = Action.COOPERATE;
				}
			}
			history1.addMove(action1);
			history2.addMove(action2);
		}
		return history2.toString();
	}
	
	protected void buildMatrix(Population population, int horizon) {
		this.horizon = horizon;
		cube = new String[strategies.size()][strategies.size()][2 * horizon + 2];
		for (int i = 0; i < strategies.size(); i++) {
			RepeatedGameStrategy strategyOne = strategies.get(i);
			for (int j = 0; j < strategies.size(); j++) {
				RepeatedGameStrategy strategyTwo = strategies.get(j);
				cube[i][j][0] = playString(strategyOne,strategyTwo, 2 * horizon + 1);
				for (int k = 1; k <= 2 * horizon + 1; k++) {
					cube[i][j][k] = playString(strategyOne,strategyTwo, 2 * horizon + 1,k-1);
				}
			}
		}

	}
	

	/**
	 * @return the horizon
	 */
	public int getHorizon() {
		return horizon;
	}



	protected void buildFrequenciesTable(Population population) {
		Set<RepeatedGameStrategy> strategySet = new LinkedHashSet<RepeatedGameStrategy>();
		for (int i = 0; i < population.getSize(); i++) {
			Individual individual = population.getIndividual(i);
			RepeatedGameStrategy strategy = (RepeatedGameStrategy) individual.getStrategy();
			strategySet.add(strategy);
		}
		double popSizeD = new Integer(population.getSize()).doubleValue();
		for (Iterator<RepeatedGameStrategy> iter = strategySet.iterator(); iter.hasNext();) {
			RepeatedGameStrategy element = iter.next();
			int count = CollectionUtils.countMatches(
					population.getCollection(), new EqualRepeatedGameStrategyPredicate(
							element));
			double countD = new Integer(count).doubleValue();
			strategies.add(element);
			frequencies.add(countD / popSizeD);
		}
	}
	
	protected String playString(RepeatedGameStrategy strategyOne, RepeatedGameStrategy strategyTwo,
			int rounds) {
		History history1 = new History();
		History history2 = new History();
		for (int j = 0; j < rounds; j++) {
			Action action1 = strategyOne.nextAction(history2);
			Action action2 = strategyTwo.nextAction(history1);
			history1.addMove(action1);
			history2.addMove(action2);
		}
		return history2.toString();
	}
	
	public int numberOfStrategies() {
		return this.strategies.size();
	}
}
